/**
* github-profile-card - 3.2.0 | MIT
* (c) 2014 - 2026 Piotr Lewandowski | https://piotrl.github.io/github-profile-card/
*/

(() => {
  // src/gh-cache-storage.ts
  var CacheStorage = class {
    constructor(storage) {
      this.storage = storage;
      this.cacheName = "github-request-cache";
      this.requestCache = this.initializeCache();
    }
    get(key) {
      return this.requestCache[key];
    }
    add(url, entry) {
      this.requestCache[url] = entry;
      this.saveCache();
    }
    initializeCache() {
      try {
        const cacheData = this.storage.getItem(this.cacheName);
        if (!cacheData) {
          return {};
        }
        const cache = JSON.parse(cacheData);
        return cache && typeof cache === "object" ? cache : {};
      } catch (error) {
        console.error("Failed to parse cache:", error);
        try {
          this.storage.removeItem(this.cacheName);
        } catch (cleanupError) {
          console.error("Failed to clear corrupted cache:", cleanupError);
        }
        return {};
      }
    }
    saveCache() {
      try {
        this.storage.setItem(this.cacheName, JSON.stringify(this.requestCache));
      } catch (error) {
        console.error("Failed to save cache:", error);
        this.clearExpiredEntries(/* @__PURE__ */ new Date());
        try {
          this.storage.setItem(this.cacheName, JSON.stringify(this.requestCache));
        } catch (retryError) {
          console.error("Failed to save cache after cleanup:", retryError);
        }
      }
    }
    clearExpiredEntries(currentDate) {
      let hasChanges = false;
      for (const [url, entry] of Object.entries(this.requestCache)) {
        if (entry.lastModified) {
          const entryDate = new Date(entry.lastModified);
          if (isNaN(entryDate.getTime()) || entryDate < currentDate) {
            delete this.requestCache[url];
            hasChanges = true;
          }
        }
      }
      if (hasChanges) {
        this.saveCache();
      }
    }
  };

  // src/gh-data-loader.ts
  var API_HOST = "https://api.github.com";
  var GitHubApiLoader = class {
    constructor() {
      this.cache = new CacheStorage(window.localStorage);
    }
    async loadUserData(username) {
      if (typeof username !== "string") {
        throw new Error("Invalid username provided");
      }
      const sanitizedUsername = username.trim();
      if (!sanitizedUsername) {
        throw new Error("Username cannot be empty");
      }
      const profile = await this.fetch(
        `${API_HOST}/users/${sanitizedUsername}`
      );
      const repositories = await this.fetch(profile.repos_url);
      return { profile, repositories };
    }
    loadRepositoriesLanguages(repositories, callback) {
      if (!repositories || repositories.length === 0) {
        callback([]);
        return;
      }
      const languagesUrls = this.extractLangURLs(repositories);
      const langStats = [];
      const requestsAmount = languagesUrls.length;
      let completedRequests = 0;
      if (requestsAmount === 0) {
        callback([]);
        return;
      }
      const handleCompletion = () => {
        completedRequests++;
        if (completedRequests === requestsAmount) {
          callback(langStats);
        }
      };
      languagesUrls.forEach((repoLangUrl) => {
        this.fetch(repoLangUrl).then((repoLangs) => {
          langStats.push(repoLangs || {});
          handleCompletion();
        }).catch((error) => {
          console.warn("Failed to load languages for repository:", error);
          langStats.push({});
          handleCompletion();
        });
      });
    }
    async identifyError(response) {
      let result;
      try {
        result = await response.json();
      } catch {
        result = { message: "Failed to parse error response" };
      }
      const error = {
        message: result.message || `HTTP ${response.status}: ${response.statusText}`
      };
      if (response.status === 404) {
        error.isWrongUser = true;
      }
      const limitRequests = response.headers.get("X-RateLimit-Remaining");
      if (Number(limitRequests) === 0) {
        const resetTime = response.headers.get("X-RateLimit-Reset");
        if (resetTime) {
          error.resetDate = new Date(Number(resetTime) * 1e3);
          error.message = error.message.split("(")[0];
        }
      }
      return error;
    }
    extractLangURLs(profileRepositories) {
      return profileRepositories.filter((repo) => repo && repo.languages_url).map((repository) => repository.languages_url);
    }
    async fetch(url) {
      if (typeof url !== "string") {
        throw new Error("Invalid URL provided for fetch");
      }
      const cache = this.cache.get(url);
      let response;
      try {
        response = await fetch(url, {
          headers: this.buildHeaders(cache)
        });
      } catch (networkError) {
        throw new Error(`Network error: ${networkError.message}`);
      }
      if (response.status === 304 && cache) {
        return cache.data;
      }
      if (response.status !== 200) {
        throw await this.identifyError(response);
      }
      let jsonResponse;
      try {
        jsonResponse = await response.json();
      } catch {
        throw new Error("Failed to parse API response as JSON");
      }
      const lastModified = response.headers.get("Last-Modified");
      if (lastModified) {
        this.cache.add(url, {
          lastModified,
          data: jsonResponse
        });
      }
      return jsonResponse;
    }
    buildHeaders(cache) {
      const headers = {
        Accept: "application/vnd.github.v3+json"
      };
      if (cache?.lastModified) {
        headers["If-Modified-Since"] = cache.lastModified;
      }
      return headers;
    }
  };

  // src/gh-dom.utils.ts
  function createName(profileUrl, name) {
    const $name = document.createElement("a");
    $name.href = profileUrl;
    $name.className = "name";
    $name.appendChild(document.createTextNode(name || ""));
    return $name;
  }
  function createAvatar(avatarUrl) {
    const $avatar = document.createElement("img");
    $avatar.src = avatarUrl;
    $avatar.className = "avatar";
    $avatar.alt = "GitHub avatar";
    return $avatar;
  }

  // src/gh-dom-operator.ts
  var DOMOperator = class {
    static clearChildren($parent) {
      $parent.textContent = "";
    }
    static createError(error, username) {
      const $error = document.createElement("div");
      $error.className = "error";
      const $message = document.createElement("span");
      $message.textContent = error.message;
      $error.appendChild($message);
      if (error.isWrongUser) {
        $message.textContent = `Not found user: ${username}`;
      }
      if (error.resetDate) {
        const currentTime = (/* @__PURE__ */ new Date()).getTime();
        const resetTime = error.resetDate.getTime();
        const remainingMinutes = Math.ceil(
          (resetTime - currentTime) / (1e3 * 60)
        );
        const $remainingTime = document.createElement("span");
        $remainingTime.className = "remain";
        $remainingTime.textContent = `Come back after ${remainingMinutes} minutes`;
        $error.appendChild($remainingTime);
      }
      return $error;
    }
    static createProfile(data) {
      const $avatar = createAvatar(data.avatar_url);
      const $info = document.createElement("div");
      $info.className = "info";
      const $name = createName(data.html_url, data.name || data.login);
      const $followers = document.createElement("span");
      $followers.className = "followers-simple";
      $followers.textContent = `${data.followers} followers`;
      $info.appendChild($name);
      $info.appendChild($followers);
      const $header = document.createElement("div");
      $header.className = "header-container";
      $header.appendChild($avatar);
      $header.appendChild($info);
      const $profile = document.createElement("div");
      $profile.className = "profile";
      $profile.appendChild($header);
      return $profile;
    }
    static createTopLanguagesSection() {
      const $langsList = document.createElement("ul");
      $langsList.className = "languages";
      return $langsList;
    }
    static createTopLanguagesList(langs) {
      const sortedLanguages = Object.keys(langs).map((language) => ({
        name: language,
        stat: langs[language]
      })).sort((a, b) => b.stat - a.stat).slice(0, 3);
      return sortedLanguages.map((lang) => {
        const escapedName = this.escapeHtml(lang.name);
        return `<li>${escapedName}</li>`;
      }).join("");
    }
    static escapeHtml(text) {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }
    static createRepositoriesHeader(headerText) {
      const $repositoriesHeader = document.createElement("span");
      $repositoriesHeader.className = "header";
      $repositoriesHeader.appendChild(document.createTextNode(`${headerText}`));
      return $repositoriesHeader;
    }
    static createRepositoriesList(repositories, maxRepos) {
      const $reposList = document.createElement("div");
      $reposList.className = "repos";
      repositories.slice(0, maxRepos).map(this.createRepositoryElement).forEach((el) => $reposList.appendChild(el));
      return $reposList;
    }
    static createRepositoryElement(repository) {
      const updated = new Date(repository.updated_at);
      const $repoLink = document.createElement("a");
      $repoLink.href = repository.html_url;
      $repoLink.title = repository.description || "";
      const $repoInfo = document.createElement("div");
      $repoInfo.className = "repo-info";
      const $repoName = document.createElement("span");
      $repoName.className = "repo-name";
      $repoName.textContent = repository.name;
      const $updated = document.createElement("span");
      $updated.className = "updated";
      $updated.textContent = `Updated: ${updated.toLocaleDateString()}`;
      $repoInfo.appendChild($repoName);
      $repoInfo.appendChild($updated);
      const $star = document.createElement("span");
      $star.className = "star";
      $star.textContent = String(repository.stargazers_count);
      $repoLink.appendChild($repoInfo);
      $repoLink.appendChild($star);
      return $repoLink;
    }
  };

  // src/gh-profile-card.ts
  var GitHubCardWidget = class {
    constructor(options = {}) {
      this.apiLoader = new GitHubApiLoader();
      this.userData = null;
      this.$template = this.findTemplate(options.template);
      this.extractHtmlConfig(options, this.$template);
      this.options = this.completeConfiguration(options);
    }
    async init() {
      try {
        this.userData = await this.apiLoader.loadUserData(this.options.username);
        this.render(this.options);
      } catch (err) {
        this.render(this.options, err);
      }
    }
    refresh(options) {
      this.options = this.completeConfiguration(options);
      this.render(this.options);
    }
    completeConfiguration(options) {
      const defaultConfig = {
        username: "",
        template: "#github-card",
        sortBy: "stars",
        // possible: 'stars', 'updateTime'
        headerText: "Most starred repositories",
        maxRepos: 5,
        hideTopLanguages: false,
        theme: "light"
      };
      return {
        ...defaultConfig,
        ...options
      };
    }
    findTemplate(templateCssSelector = "#github-card") {
      const $template = document.querySelector(
        templateCssSelector
      );
      if (!$template) {
        throw new Error(`No template found for selector: ${templateCssSelector}`);
      }
      $template.className = "gh-profile-card";
      return $template;
    }
    extractHtmlConfig(widgetConfig, $template) {
      const dataset = $template.dataset;
      widgetConfig.username = widgetConfig.username || dataset.username;
      widgetConfig.sortBy = widgetConfig.sortBy || dataset.sortBy;
      widgetConfig.headerText = widgetConfig.headerText || dataset.headerText;
      if (dataset.maxRepos) {
        const parsedMaxRepos = parseInt(dataset.maxRepos, 10);
        if (!isNaN(parsedMaxRepos)) {
          widgetConfig.maxRepos = widgetConfig.maxRepos || parsedMaxRepos;
        }
      }
      widgetConfig.hideTopLanguages = widgetConfig.hideTopLanguages || dataset.hideTopLanguages === "true";
      widgetConfig.theme = (widgetConfig.theme || dataset.theme) ?? "light";
      if (!widgetConfig.username) {
        throw new Error("Username is required but not provided");
      }
    }
    render(options, error) {
      const $root = this.$template;
      DOMOperator.clearChildren($root);
      if (options.theme === "black") {
        $root.classList.add("theme-black");
      } else {
        $root.classList.remove("theme-black");
      }
      if (error) {
        const $errorSection = DOMOperator.createError(
          error,
          options.username || ""
        );
        $root.appendChild($errorSection);
        return;
      }
      const repositories = this.userData.repositories;
      this.sortRepositories(repositories, options.sortBy || "stars");
      const $profile = DOMOperator.createProfile(this.userData.profile);
      if (!options.hideTopLanguages) {
        $profile.appendChild(this.createTopLanguagesSection(repositories));
      }
      $root.appendChild($profile);
      if ((options.maxRepos || 0) > 0) {
        const $reposHeader = DOMOperator.createRepositoriesHeader(
          options.headerText || "Repositories"
        );
        const $reposList = DOMOperator.createRepositoriesList(
          repositories,
          options.maxRepos || 5
        );
        $reposList.insertBefore($reposHeader, $reposList.firstChild);
        $root.appendChild($reposList);
      }
    }
    createTopLanguagesSection(repositories) {
      const $topLanguages = DOMOperator.createTopLanguagesSection();
      if (!repositories || repositories.length === 0) {
        return $topLanguages;
      }
      this.apiLoader.loadRepositoriesLanguages(
        repositories.slice(0, 10),
        (langStats) => {
          if (langStats.length > 0) {
            const languagesRank = this.groupLanguagesUsage(langStats);
            $topLanguages.innerHTML = DOMOperator.createTopLanguagesList(languagesRank);
          }
        }
      );
      return $topLanguages;
    }
    groupLanguagesUsage(langStats) {
      const languagesRank = {};
      langStats.forEach((repoLangs) => {
        if (repoLangs && typeof repoLangs === "object") {
          Object.entries(repoLangs).forEach(([language, bytes]) => {
            if (typeof bytes === "number" && bytes > 0) {
              languagesRank[language] = (languagesRank[language] || 0) + bytes;
            }
          });
        }
      });
      return languagesRank;
    }
    sortRepositories(repos, sortBy) {
      if (!repos || repos.length === 0) {
        return;
      }
      repos.sort((firstRepo, secondRepo) => {
        if (sortBy === "stars") {
          const starDifference = secondRepo.stargazers_count - firstRepo.stargazers_count;
          if (starDifference !== 0) {
            return starDifference;
          }
        }
        return this.dateDifference(secondRepo.updated_at, firstRepo.updated_at);
      });
    }
    dateDifference(first, second) {
      const firstDate = new Date(first);
      const secondDate = new Date(second);
      if (isNaN(firstDate.getTime()) || isNaN(secondDate.getTime())) {
        return 0;
      }
      return firstDate.getTime() - secondDate.getTime();
    }
  };

  // src/css/base.scss
  var css = `@charset "UTF-8";
/**
 * Github widget styles 
 * ------------------------------------------------------------------
 */
.gh-profile-card {
  /* List of repositories */
  /* Specific adjustment for dark theme repository items if needed */
}
.gh-profile-card :root {
  --gh-card-bg: #fafafa;
  --gh-card-border: #ddd;
  --gh-card-text: #444;
  --gh-card-name: #222;
  --gh-card-link: #4183c4;
  --gh-card-header-bg-start: #fafafa;
  --gh-card-header-bg-end: #eaeaea;
  --gh-card-header-border: #d5d5d5;
  --gh-card-header-text: #555;
}
.gh-profile-card .theme-black {
  --gh-card-bg: #0d1117;
  --gh-card-border: #30363d;
  --gh-card-text: #8b949e;
  --gh-card-name: #c9d1d9;
  --gh-card-link: #58a6ff;
  --gh-card-header-bg-start: #161b22;
  --gh-card-header-bg-end: #0d1117;
  --gh-card-header-border: #30363d;
  --gh-card-header-text: #c9d1d9;
}
.gh-profile-card {
  width: 100%;
  max-width: 380px;
  border-radius: 8px;
  font-size: 14px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
  background: var(--gh-card-bg);
  border: 1px solid var(--gh-card-border);
  overflow: hidden;
  color: var(--gh-card-text);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}
.gh-profile-card a {
  text-decoration: none;
  color: var(--gh-card-text);
}
.gh-profile-card a:hover {
  color: var(--gh-card-link);
}
.gh-profile-card .name {
  display: block;
  font-size: 1.2em;
  font-weight: bold;
  color: var(--gh-card-name);
}
.gh-profile-card .error {
  font-size: 0.8em;
  color: var(--gh-card-text);
  padding: 10px;
}
.gh-profile-card .error span {
  display: block;
  border-bottom: 1px solid var(--gh-card-border);
  padding-bottom: 5px;
  margin-bottom: 5px;
}
.gh-profile-card .error span.remain {
  text-align: center;
  font-weight: bold;
}
.gh-profile-card .profile {
  background: var(--gh-card-bg);
  overflow: hidden;
  padding: 15px;
}
.gh-profile-card .header-container {
  display: flex;
  align-items: flex-start;
  margin-bottom: 15px;
}
.gh-profile-card .avatar {
  width: 80px;
  height: 80px;
  border-radius: 8px;
  box-shadow: 0 0 4px rgba(0, 0, 0, 0.1);
  margin-right: 15px;
}
.gh-profile-card .info {
  display: flex;
  flex-direction: column;
}
.gh-profile-card .name {
  font-size: 1.5em;
  line-height: 1.2;
  margin-bottom: 10px;
  word-break: break-word;
}
.gh-profile-card .followers-simple {
  font-size: 0.9em;
  color: #666;
  margin-top: -5px;
}
.gh-profile-card .languages {
  margin: 15px 0 0 0;
  padding: 10px 0 0 0;
  border-top: 1px solid var(--gh-card-border);
  list-style: none;
  font-size: 0.9em;
}
.gh-profile-card .languages::before {
  content: "Top languages";
  display: block;
  font-size: 0.85em;
  font-style: italic;
  color: var(--gh-card-text);
  margin-bottom: 5px;
}
.gh-profile-card .languages li {
  display: inline-block;
  color: var(--gh-card-text);
  font-weight: bold;
  margin-right: 15px;
}
.gh-profile-card .languages li::after {
  content: "\u2022";
  margin-left: 10px;
  opacity: 0.3;
}
.gh-profile-card .languages li:last-child::after {
  content: "";
}
.gh-profile-card .repos {
  clear: both;
}
.gh-profile-card .repos .header {
  display: block;
  width: 100%;
  font-weight: bold;
  background: var(--gh-card-header-bg-end);
  background-image: linear-gradient(var(--gh-card-header-bg-start), var(--gh-card-header-bg-end));
  border: solid var(--gh-card-header-border);
  border-width: 1px 0;
  color: var(--gh-card-header-text);
  font-size: 1em;
  padding: 8px 15px;
}
.gh-profile-card .repos a {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 15px;
  text-decoration: none;
  border-top: 1px solid var(--gh-card-border);
  transition: background 0.2s;
}
.gh-profile-card .repos a:hover {
  background: rgba(0, 0, 0, 0.02);
}
.gh-profile-card .repos a:first-of-type {
  border-top: none;
}
.gh-profile-card .repos .repo-info {
  display: flex;
  flex-direction: column;
  flex: 1;
}
.gh-profile-card .repos .repo-name {
  display: block;
  font-weight: bold;
  font-size: 1.1em;
  color: var(--gh-card-name);
  margin-bottom: 2px;
}
.gh-profile-card .repos .updated {
  font-size: 0.85em;
  font-style: italic;
  color: #888;
}
.gh-profile-card .repos .star {
  font-size: 1.1em;
  color: #888;
  display: flex;
  align-items: center;
  margin-left: 15px;
}
.gh-profile-card .repos .star::after {
  content: "\u2605";
  margin-left: 4px;
  font-size: 1.2em;
}
.gh-profile-card .theme-black .repos .updated,
.gh-profile-card .theme-black .repos .star {
  color: var(--gh-card-text);
}`;
  document.head.appendChild(document.createElement("style")).appendChild(document.createTextNode(css));

  // src/gh-widget-init.ts
  window.GitHubCard = GitHubCardWidget;
  document.addEventListener("DOMContentLoaded", () => {
    const urlParams = new URLSearchParams(window.location.search);
    const usernameFromUrl = urlParams.get("username") || window.location.search.substring(1).split("&")[0];
    const themeFromUrl = urlParams.get("theme");
    const $defaultTemplate = document.querySelector("#github-card");
    if (usernameFromUrl || $defaultTemplate) {
      try {
        const options = {
          username: usernameFromUrl || void 0,
          theme: themeFromUrl || void 0
        };
        const widget = new GitHubCardWidget(options);
        widget.init().catch((error) => {
          console.error("Failed to initialize GitHub Card widget:", error);
        });
      } catch (error) {
        console.error("Failed to construct GitHub Card widget:", error);
      }
    }
  });
})();
